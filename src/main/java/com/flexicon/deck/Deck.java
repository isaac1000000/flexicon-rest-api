package com.flexicon.deck;

import com.flexicon.rel.RelDTO;
import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.DiscriminatorFormula;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * An abstract deck superclass that contains all columns of a row in the deck table.
 * Each row contains the storage location and generation metadata of a deck file.
 *
 * @author isaac1000000
 */
@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@Table(name="decks")
@DiscriminatorFormula("type")
public abstract class Deck<CardType extends Card> {

    protected static final String DECK_DIRECTORY = "/files/decks/";

    /**
     * The unique id of the deck, autogenerated on the database side.
     */
    @Id
    @Column(name="id")
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;

    /**
     * The type of deck (ex: 'anki').
     */
    @Column(name="type")
    @Enumerated(EnumType.STRING)
    private DeckType type;

    /**
     * The user-provided name for the deck. Optional.
     */
    @Column(name="name")
    private String name;

    /**
     * The extension for the exported deck file
     */
    @Column(name="ext")
    @Enumerated(EnumType.STRING)
    private Extension ext;

    /**
     * The size (total number of elements) in the deck.
     */
    @Column(name="size")
    protected int size;

    /**
     * The deck's date of creation.
     */
    @Column(name="createdAt")
    @CreationTimestamp
    private Date createdAt;

    /**
     * Creation metadata: the minimum acceptable target frequency value. Optional.
     */
    @Column(name="minFrequency")
    private Double minFrequency;

    /**
     * Creation metadata: the maximum acceptable target frequency value. Optional.
     */
    @Column(name="maxFrequency")
    private Double maxFrequency;

    /**
     * Creation metadata: the minimum acceptable relationship strength value. Optional.
     */
    @Column(name="minStrength")
    private Double minStrength;

    /**
     * Creation metadata: the maximum acceptable relationship strength value. Optional.
     */
    @Column(name="maxStrength")
    private Double maxStrength;

    /**
     * The list of cards that make up the deck.
     */
    @Transient
    private List<CardType> cardList = new ArrayList<CardType>();

    /**
     * A function to be implemented by subclasses that will create the file then internally update the current size.
     */
    public abstract void export();

    public Long getId() {
        return id;
    }

    public DeckType getType() {
        return type;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getExt() {
        return "." + ext.toString().toLowerCase();
    }

    public void setExt(Extension ext) {
        this.ext = ext;
    }

    public Extension getExtRaw() {
        return ext;
    }

    public int getSize() {
        return size;
    }

    public Date getCreatedAt() {
        return createdAt;
    }

    public Double getMinFrequency() {
        return minFrequency;
    }

    public void setMinFrequency(Double minFrequency) {
        this.minFrequency = minFrequency;
    }

    public Double getMaxFrequency() {
        return maxFrequency;
    }

    public void setMaxFrequency(Double maxFrequency) {
        this.maxFrequency = maxFrequency;
    }

    public Double getMinStrength() {
        return minStrength;
    }

    public void setMinStrength(Double minStrength) {
        this.minStrength = minStrength;
    }

    public Double getMaxStrength() {
        return maxStrength;
    }

    public void setMaxStrength(Double maxStrength) {
        this.maxStrength = maxStrength;
    }

    public List<CardType> getCardList() {
        return cardList;
    }

    public void addCard(CardType card) {
        cardList.add(card);
    }

    /**
     * A method for adding a card from the information stored in a {@link RelDTO} object.
     *
     * @param relDTO the source for the new card
     */
    public abstract void addTargetFromRel(RelDTO relDTO);

    /**
     * Returns card at index <code>i</code>.
     *
     * @param i the index of the returned card
     * @return the card at index <code>i</code>
     */
    public CardType get(int i) {
        return cardList.get(i);
    }

    /**
     * Generates the deck's filepath from its <code>id</code> and <code>type</code>.
     *
     * @return The filepath of the deck
     */
     public String getFilepath() {
        return type.toString().toLowerCase() + "_deck_" + Long.toString(id) + getExt();
     }

     public Deck() { }

    public Deck(DeckType type, Extension ext) {
         this.type = type;
         this.ext = ext;
    }

    public Deck(DeckType type, String name, Extension ext) {
         this.type = type;
         this.name = name;
         this.ext = ext;
     }
}
